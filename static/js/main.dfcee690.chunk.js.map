{"version":3,"sources":["controllers/VisualController/index.tsx","controllers/ShellyController/config.ts","controllers/ShellyController/index.tsx","controllers/controller.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx"],"names":["VisualController","analyser","running","canvasRef","useRef","useState","canvasCtx","setCanvasCtx","drawVisual","setDrawVisual","useEffect","current","getContext","WIDTH","width","HEIGHT","height","bufferLength","frequencyBinCount","console","log","dataArray","Uint8Array","clearRect","draw","setDrawVisual_","requestAnimationFrame","getByteFrequencyData","fillStyle","fillRect","barHeight","barWidth","x","i","visualize","window","cancelAnimationFrame","stop","Box","border","color","size","pad","alignSelf","ref","config","ipRangePrefix","defaultDelay","channels","name","threshold","devices","ip","type","delay","shellyEndPoints","relay","endpoint","aliases","ShellyController","audioData","setChannels","debugHTMLStatus","setDebugHTMLStatus","setShellyEndPointsMap","setPercentFactor","setIpRangePrefix","shellyEndPointsMap_","item","_item","alias","channels_","length","_debugHTMLStatus","forEach","channel","device","turn","loopingFunction","getByteTimeDomainData","_audioData","max","Math","amount","indexOf","direction","justify","margin","wrap","flex","Object","entries","map","index","key","values","Heading","level","background","Controller","audioCtx","setAudioCtx","audioInput","setAudioInput","setAnalyser","setRunning","stream","setStream","undefined","navigator","mediaDevices","getUserMedia","constraints","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","Promise","resolve","reject","call","Error","_audioCtx","AudioContext","webkitAudioContext","setupMic","a","makeDistortionCurve","k","n_samples","curve","Float32Array","deg","PI","abs","analyser_","createAnalyser","minDecibels","maxDecibels","smoothingTimeConstant","fftSize","distortion","createWaveShaper","gainNode","createGain","biquadFilter","createBiquadFilter","convolver","createConvolver","audio","video","stream_","audioInput_","createMediaStreamSource","connect","oversample","gain","setTargetAtTime","currentTime","disconnect","start","round","Header","corner","side","Main","gap","Button","onClick","getAudioTracks","track","label","App","Grommet","theme","grommet","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","error","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.dfcee690.chunk.js","sourcesContent":["import React, { FC, useEffect, useRef, useState } from 'react';\nimport { Box } from 'grommet';\n\nexport interface I_VisualController_Props {\n\tanalyser: AnalyserNode | null;\n\trunning: boolean;\n}\n\nconst VisualController: FC<I_VisualController_Props> = ({ analyser, running }: I_VisualController_Props) => {\n\tconst canvasRef = useRef<any>();\n\tconst [canvasCtx, setCanvasCtx] = useState<any>(null);\n\tconst [drawVisual, setDrawVisual] = useState<number>(0);\n\n\tuseEffect(() => {\n\t\tsetCanvasCtx(canvasRef.current.getContext('2d'));\n\t}, []);\n\n\tconst visualize = () => {\n\t\tconst WIDTH = canvasRef.current.width;\n\t\tconst HEIGHT = canvasRef.current.height;\n\n\t\tif (!running || !analyser) return;\n\n\t\tconst bufferLength = analyser.frequencyBinCount;\n\t\tconsole.log(bufferLength);\n\t\tconst dataArray = new Uint8Array(bufferLength);\n\n\t\tcanvasCtx.clearRect(0, 0, WIDTH, HEIGHT);\n\n\t\t//reference this using self\n\t\tconst draw = () => {\n\t\t\tif (!running || !analyser) return;\n\t\t\tconst setDrawVisual_ = requestAnimationFrame(draw);\n\t\t\tsetDrawVisual(setDrawVisual_);\n\t\t\tanalyser.getByteFrequencyData(dataArray);\n\t\t\tcanvasCtx.fillStyle = 'rgb(0, 0, 0)';\n\t\t\tcanvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\n\t\t\tconst barWidth = (WIDTH / bufferLength) * 2.5;\n\t\t\t// const barWidth = WIDTH / (bufferLength + 0.7);\n\t\t\tlet barHeight;\n\t\t\tlet x = 0;\n\t\t\tfor (let i = 0; i < bufferLength; i++) {\n\t\t\t\tbarHeight = dataArray[i];\n\t\t\t\tcanvasCtx.fillStyle = 'rgb(' + (barHeight + 100) + ',50,50)';\n\t\t\t\tcanvasCtx.fillRect(x, HEIGHT - barHeight / 2, barWidth, barHeight / 2);\n\t\t\t\tx += barWidth + 1;\n\t\t\t}\n\t\t};\n\n\t\tdraw();\n\t};\n\n\tconst stop = () => {\n\t\tif (canvasCtx) {\n\t\t\twindow.cancelAnimationFrame(drawVisual);\n\t\t\tconst WIDTH = canvasRef.current.width;\n\t\t\tconst HEIGHT = canvasRef.current.height;\n\t\t\tcanvasCtx.fillStyle = '#7D4CDB';\n\t\t\tcanvasCtx.fillRect(0, 0, WIDTH, HEIGHT);\n\t\t}\n\t};\n\n\tuseEffect(() => {\n\t\tif (running && analyser) {\n\t\t\tvisualize();\n\t\t} else {\n\t\t\tstop();\n\t\t}\n\t}, [running]);\n\n\treturn (\n\t\t<>\n\t\t\t<Box width=\"large\" border={{ color: 'brand', size: 'small' }} pad=\"xsmall\" alignSelf=\"center\">\n\t\t\t\t<canvas ref={canvasRef}></canvas>\n\t\t\t</Box>\n\t\t</>\n\t);\n};\n\nexport default VisualController;\n","const config = {\n\tipRangePrefix: '192.168.0',\n\tdefaultDelay: 200,\n\tchannels: [\n\t\t{\n\t\t\tname: 'Schneemann links',\n\t\t\t// threshold: 165,\n\t\t\tthreshold: 1,\n\t\t\tdevices: [\n\t\t\t\t{\n\t\t\t\t\tip: '11',\n\t\t\t\t\ttype: 'shelly1',\n\t\t\t\t\tname: 'Schneemann links',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tname: 'channel2',\n\t\t\tthreshold: 180,\n\t\t\tdelay: 100,\n\t\t\tdevices: [\n\t\t\t\t{\n\t\t\t\t\tip: '12',\n\t\t\t\t\ttype: 'shelly1',\n\t\t\t\t\tname: 'Lichter links',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tip: '13',\n\t\t\t\t\ttype: 'shelly1',\n\t\t\t\t\tname: 'Lichter rechts',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tname: 'channel4',\n\t\t\tthreshold: 140,\n\t\t\tdevices: [\n\t\t\t\t{\n\t\t\t\t\tip: '15',\n\t\t\t\t\ttype: 'shelly1',\n\t\t\t\t\tname: 'Schneemann rechts',\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t],\n};\n\nexport default config;\n","import React, { FC, useEffect, useState } from 'react';\nimport { Box, Heading } from 'grommet';\nimport config from './config';\n\ntype T_ShellyTypes = 'shelly1' | 'shelly2' | 'shelly2.5' | 'shelly1pm';\ntype T_Endpoints = 'relay';\ntype T_Device = { ip: string; type: T_ShellyTypes; name: string };\ntype T_Channel = { name: string; threshold: number; devices: T_Device[]; delay?: number };\n\ntype T_DebugHTMLStatus_Value = { turn: 'on' | 'off'; timer?: string };\ntype T_DebugHTMLStatus = Record<string, T_DebugHTMLStatus_Value>;\n\ntype T_ShellyEndPoint = { endpoint: T_Endpoints; aliases: T_ShellyTypes[] };\ntype T_ShellyEndPoints = Record<T_Endpoints, T_ShellyEndPoint>;\ntype T_ShellyEndPointsMap = Record<T_Endpoints | T_ShellyTypes, T_Endpoints>;\n\nconst shellyEndPoints: T_ShellyEndPoints = {\n\trelay: {\n\t\tendpoint: 'relay',\n\t\taliases: ['shelly1', 'shelly1pm', 'shelly2', 'shelly2.5'],\n\t},\n};\n\nconst debug = true;\nconst threshold = 100;\nconst numberOflastTurnOns = 5;\n\nexport interface I_ShellyController_Props {\n\tanalyser: AnalyserNode | null;\n\trunning: boolean;\n}\n\nconst ShellyController: FC<I_ShellyController_Props> = ({ analyser, running }: I_ShellyController_Props) => {\n\tconst [channels, setChannels] = useState<T_Channel[]>([]);\n\tconst [debugHTMLStatus, setDebugHTMLStatus] = useState<T_DebugHTMLStatus>({});\n\tconst [shellyEndPointsMap, setShellyEndPointsMap] = useState<T_ShellyEndPointsMap>({} as T_ShellyEndPointsMap);\n\tconst [percentFactor, setPercentFactor] = useState<number>(0);\n\tconst [ipRangePrefix, setIpRangePrefix] = useState<string>('');\n\n\tlet lastCalculatedChannel: number;\n\tlet channelValuesSum: number;\n\tlet channelValuesCount: number;\n\tlet audioData: Uint8Array;\n\n\tconst lastStatus: Record<string, boolean> = {};\n\tconst statusHistory: Record<string, boolean[]> = {};\n\tconst throttleTimer: Record<string, any> = {};\n\n\tuseEffect(() => {\n\t\tconst shellyEndPointsMap_: T_ShellyEndPointsMap = {} as T_ShellyEndPointsMap;\n\t\tfor (const item in shellyEndPoints) {\n\t\t\tconst _item = item as T_Endpoints;\n\t\t\tshellyEndPointsMap_[_item] = _item;\n\t\t\tfor (const alias in shellyEndPoints[_item].aliases) {\n\t\t\t\tshellyEndPointsMap_[shellyEndPoints[_item].aliases[alias]] = _item;\n\t\t\t}\n\t\t}\n\t\tsetShellyEndPointsMap(shellyEndPointsMap_);\n\n\t\tconst channels_ = config.channels as T_Channel[];\n\t\tsetChannels(channels_);\n\t\tsetIpRangePrefix(config.ipRangePrefix);\n\t\tsetPercentFactor(100 / channels_.length);\n\t\tconst _debugHTMLStatus: T_DebugHTMLStatus = {};\n\t\tchannels_.forEach((channel) => {\n\t\t\tchannel.devices.forEach((device) => {\n\t\t\t\t_debugHTMLStatus[device.name] = { turn: 'off' };\n\t\t\t});\n\t\t});\n\t\tsetDebugHTMLStatus(_debugHTMLStatus);\n\t}, []);\n\n\tconst throttle = (callable: any, delay: number, timerId: string, ...args: any) => {\n\t\tif (throttleTimer[timerId]) {\n\t\t\treturn;\n\t\t}\n\t\tcallable(timerId, ...args);\n\t\tthrottleTimer[timerId] = setTimeout(function () {\n\t\t\tthrottleTimer[timerId] = undefined;\n\t\t}, delay);\n\t};\n\n\tconst fillHTMLDebugData = (channelName: string, value: T_DebugHTMLStatus_Value) => {\n\t\tif (debug !== true) {\n\t\t\treturn;\n\t\t}\n\t\tconst _debugHTMLStatus: T_DebugHTMLStatus = { ...debugHTMLStatus };\n\t\t_debugHTMLStatus[channelName] = value;\n\t\tsetDebugHTMLStatus(_debugHTMLStatus);\n\t};\n\n\tconst shellyEndPoint = (item: T_ShellyTypes) => {\n\t\treturn shellyEndPoints[shellyEndPointsMap[item]].endpoint;\n\t};\n\n\tconst lights = (channelId: number, turnOn: boolean) => {\n\t\tif (channelId === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tstatusHistory[channelId].push(turnOn);\n\n\t\tif (false === turnOn && turnOn === lastStatus[channelId]) {\n\t\t\treturn;\n\t\t}\n\n\t\tlastStatus[channelId] = turnOn;\n\t\tconst channel = channels[channelId];\n\t\tconst turn = turnOn ? 'on' : 'off';\n\t\tconst timer = turnOn ? '&timer=1' : '';\n\t\tconst requestOptions = {\n\t\t\tmethod: 'GET',\n\t\t\tredirect: 'follow',\n\t\t\tmode: 'no-cors',\n\t\t};\n\n\t\tif (channel.devices === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tchannel.devices.forEach(async (device: T_Device, deviceId: number) => {\n\t\t\tfillHTMLDebugData(device.name, { turn, timer });\n\n\t\t\t// console.log(\n\t\t\t// \t`http://${ipRangePrefix}.${device.ip}/${shellyEndPoint(\n\t\t\t// \t\tdevice.type,\n\t\t\t// \t)}/0?turn=${turn}${timer}${brightness}${color}`,\n\t\t\t// );\n\t\t\t// fetch(\n\t\t\t// \t`http://${ipRangePrefix}.${device.ip}/${shellyEndPoint(\n\t\t\t// \t\tdevice.type,\n\t\t\t// \t)}/0?turn=${turn}${timer}${brightness}${color}`,\n\t\t\t// \trequestOptions as any,\n\t\t\t// )\n\t\t\t// \t.then((response) => response.text())\n\t\t\t// \t.then((result) => console.log(result))\n\t\t\t// \t.catch((error) => console.log('error', error));\n\t\t});\n\t};\n\n\tconst drawLightShow = (channelNumber: number, audioValue: number, bar: number) => {\n\t\tif (channelNumber > lastCalculatedChannel) {\n\t\t\tif (statusHistory[lastCalculatedChannel] === undefined) {\n\t\t\t\tstatusHistory[lastCalculatedChannel] = [];\n\t\t\t}\n\t\t\tlet channelThreshold = channels[lastCalculatedChannel].threshold || threshold;\n\t\t\tconst lastFiveHistoricalStatus = statusHistory[lastCalculatedChannel].slice(-numberOflastTurnOns);\n\t\t\tconst throttleDelay = channels[lastCalculatedChannel].delay || config.defaultDelay || 500;\n\n\t\t\tif (lastFiveHistoricalStatus.length > 0) {\n\t\t\t\tconst lastTurnOns = lastFiveHistoricalStatus.reduce(\n\t\t\t\t\t(accumulator, currentValue) => (currentValue ? accumulator + 1 : accumulator),\n\t\t\t\t\t0,\n\t\t\t\t);\n\t\t\t\tconst turnOnsFactor = lastTurnOns / numberOflastTurnOns;\n\t\t\t\tif (turnOnsFactor >= 1) {\n\t\t\t\t\tchannelThreshold = channelThreshold * 1.5;\n\t\t\t\t} else if (turnOnsFactor <= 0.3) {\n\t\t\t\t\tchannelThreshold = channelThreshold * 0.8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst calculatedValue = Math.floor(channelValuesSum / channelValuesCount);\n\t\t\tconst turnOn = calculatedValue >= channelThreshold;\n\t\t\tif (turnOn) {\n\t\t\t\tconsole.log(\n\t\t\t\t\tchannels[lastCalculatedChannel].name,\n\t\t\t\t\t'on',\n\t\t\t\t\tchannelValuesSum,\n\t\t\t\t\tchannelValuesCount,\n\t\t\t\t\tchannelThreshold,\n\t\t\t\t\taudioValue,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!turnOn) {\n\t\t\t\tconsole.log(\n\t\t\t\t\tchannels[lastCalculatedChannel].name,\n\t\t\t\t\t'off',\n\t\t\t\t\tchannelValuesSum,\n\t\t\t\t\tchannelValuesCount,\n\t\t\t\t\tchannelThreshold,\n\t\t\t\t\taudioValue,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrottle(lights, throttleDelay, lastCalculatedChannel.toString(), turnOn);\n\t\t\tchannelValuesCount = 1;\n\t\t\tchannelValuesSum = 0;\n\t\t}\n\t\tchannelValuesCount++;\n\t\tchannelValuesSum = channelValuesSum + audioValue;\n\t\tlastCalculatedChannel = channelNumber;\n\t};\n\n\tconst calculateChannel = (bar: number): number => {\n\t\tconst percent = Math.floor((bar / 200) * 100);\n\t\tlet channel = Math.ceil(percent / percentFactor) - 1;\n\n\t\tif (channel < 0) {\n\t\t\tchannel = 0;\n\t\t} else if (channel >= channels.length) {\n\t\t\tchannel = channels.length - 1;\n\t\t}\n\t\treturn channel;\n\t};\n\n\tconst draw = (audioData: Uint8Array) => {\n\t\tconst _audioData = [...audioData];\n\t\tchannelValuesSum = 0;\n\t\tchannelValuesCount = 1;\n\t\tlastCalculatedChannel = 0;\n\t\t// _audioData.forEach((audioValue, bar) => {\n\t\t// \tif (audioValue > 170) {\n\t\t// \t\tconsole.log(audioValue, bar);\n\t\t// \t\tconst channelNumber = calculateChannel(bar);\n\t\t// \t\tif (channelNumber) {\n\t\t// \t\t\tdrawLightShow(channelNumber, audioValue, bar);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// });\n\t\tconst max = Math.max(..._audioData);\n\t\tconst amount = _audioData.length;\n\t\tconst indexOf = _audioData.indexOf(max);\n\t\tif (max > 170 && indexOf > 800) {\n\t\t\tconsole.log(max, amount, indexOf);\n\t\t}\n\t};\n\n\tconst loopingFunction = () => {\n\t\tif (!running || !analyser) return;\n\t\trequestAnimationFrame(loopingFunction);\n\t\t// analyser.getByteFrequencyData(audioData);\n\t\tanalyser.getByteTimeDomainData(audioData);\n\t\tdraw(audioData);\n\t};\n\n\tuseEffect(() => {\n\t\tif (running && analyser) {\n\t\t\taudioData = new Uint8Array(analyser.frequencyBinCount);\n\t\t\tloopingFunction();\n\t\t}\n\t}, [running]);\n\n\treturn (\n\t\t<>\n\t\t\t{debug && debugHTMLStatus && (\n\t\t\t\t<Box direction=\"row\" alignSelf=\"center\" justify=\"center\" margin=\"small\" wrap flex>\n\t\t\t\t\t{Object.entries(debugHTMLStatus).map(([key, values], index: number) => (\n\t\t\t\t\t\t<Box key={`device-${index}`} pad=\"xsmall\" margin=\"small\">\n\t\t\t\t\t\t\t<Box>\n\t\t\t\t\t\t\t\t<Heading level=\"5\" margin=\"none\">\n\t\t\t\t\t\t\t\t\t{key}\n\t\t\t\t\t\t\t\t</Heading>\n\t\t\t\t\t\t\t\t<Box background={values.turn === 'off' ? 'light-3' : 'accent-4'}>\n\t\t\t\t\t\t\t\t\t<Box alignSelf=\"center\">{values.turn ?? '-'}</Box>\n\t\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t\t</Box>\n\t\t\t\t\t\t</Box>\n\t\t\t\t\t))}\n\t\t\t\t</Box>\n\t\t\t)}\n\t\t</>\n\t);\n};\n\nexport default ShellyController;\n","import { Box, Button, Header, Main, Heading } from 'grommet';\nimport React, { FC, useEffect, useState } from 'react';\nimport VisualController from './VisualController';\nimport ShellyController from './ShellyController';\n\nconst Controller: FC<any> = () => {\n\tconst [audioCtx, setAudioCtx] = useState<AudioContext | null>(null);\n\tconst [audioInput, setAudioInput] = useState<MediaStreamAudioSourceNode | null>(null);\n\tconst [analyser, setAnalyser] = useState<AnalyserNode | null>(null);\n\tconst [running, setRunning] = useState<boolean>(false);\n\tconst [stream, setStream] = useState<MediaStream | null>(null);\n\n\tuseEffect(() => {\n\t\t// Some browsers partially implement mediaDevices. We can't just assign an object\n\t\t// with getUserMedia as it would overwrite existing properties.\n\t\t// Here, we will just add the getUserMedia property if it's missing.\n\t\tif (navigator.mediaDevices.getUserMedia === undefined) {\n\t\t\tnavigator.mediaDevices.getUserMedia = function (constraints) {\n\t\t\t\t// First get ahold of the legacy getUserMedia, if present\n\t\t\t\tconst getUserMedia =\n\t\t\t\t\t(navigator as any).webkitGetUserMedia ||\n\t\t\t\t\t(navigator as any).mozGetUserMedia ||\n\t\t\t\t\t(navigator as any).msGetUserMedia;\n\n\t\t\t\t// Some browsers just don't implement it - return a rejected promise with an error\n\t\t\t\t// to keep a consistent interface\n\t\t\t\tif (!getUserMedia) {\n\t\t\t\t\treturn Promise.reject(new Error('getUserMedia is not implemented in this browser'));\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tgetUserMedia.call(navigator, constraints, resolve, reject);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\n\t\t// (navigator as any).getUserMedia =\n\t\t// \t(navigator as any).getUserMedia ||\n\t\t// \t(navigator as any).webkitGetUserMedia ||\n\t\t// \t(navigator as any).mozGetUserMedia;\n\n\t\tconst _audioCtx: AudioContext = new window.AudioContext() || (window as any).webkitAudioContext;\n\t\tsetAudioCtx(_audioCtx);\n\t}, []);\n\n\tconst setupMic = async () => {\n\t\tif (audioCtx === null) return;\n\t\ttry {\n\t\t\tconst analyser_ = audioCtx.createAnalyser();\n\t\t\tanalyser_.minDecibels = -90;\n\t\t\tanalyser_.maxDecibels = -10;\n\t\t\tanalyser_.smoothingTimeConstant = 0.85;\n\t\t\tanalyser_.fftSize = 256;\n\t\t\t// analyser_.fftSize = 64;\n\t\t\tsetAnalyser(analyser_);\n\n\t\t\tconst distortion = audioCtx.createWaveShaper();\n\t\t\tconst gainNode = audioCtx.createGain();\n\t\t\tconst biquadFilter = audioCtx.createBiquadFilter();\n\t\t\tconst convolver = audioCtx.createConvolver();\n\n\t\t\tlet stream_: MediaStream;\n\t\t\t(window as any).stream = stream_ = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n\t\t\tconst audioInput_ = audioCtx.createMediaStreamSource(stream_);\n\t\t\tsetStream(stream_);\n\n\t\t\taudioInput_.connect(distortion);\n\t\t\tdistortion.connect(biquadFilter);\n\t\t\tbiquadFilter.connect(gainNode);\n\t\t\tconvolver.connect(gainNode);\n\t\t\tgainNode.connect(analyser_);\n\n\t\t\tsetAudioInput(audioInput_);\n\n\t\t\tfunction makeDistortionCurve(amount: number) {\n\t\t\t\tconst k = typeof amount === 'number' ? amount : 50,\n\t\t\t\t\tn_samples = 44100,\n\t\t\t\t\tcurve = new Float32Array(n_samples),\n\t\t\t\t\tdeg = Math.PI / 180;\n\t\t\t\tlet i = 0;\n\t\t\t\tlet x;\n\t\t\t\tfor (; i < n_samples; ++i) {\n\t\t\t\t\tx = (i * 2) / n_samples - 1;\n\t\t\t\t\tcurve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));\n\t\t\t\t}\n\t\t\t\treturn curve;\n\t\t\t}\n\n\t\t\tdistortion.oversample = '4x';\n\t\t\tbiquadFilter.gain.setTargetAtTime(0, audioCtx.currentTime, 0);\n\t\t\tbiquadFilter.disconnect(0);\n\t\t\tbiquadFilter.connect(gainNode);\n\n\t\t\tdistortion.curve = makeDistortionCurve(400);\n\n\t\t\t// biquadFilter.type = 'lowshelf';\n\t\t\t// biquadFilter.frequency.setTargetAtTime(1000, audioCtx.currentTime, 0);\n\t\t\t// biquadFilter.gain.setTargetAtTime(25, audioCtx.currentTime, 0);\n\n\t\t\tsetRunning(true);\n\t\t} catch (err) {\n\t\t\t//TODO: error getting stream\n\t\t\tconsole.log('Error: Issue getting mic', err);\n\t\t}\n\t};\n\n\tconst start = async () => {\n\t\tawait setupMic();\n\t};\n\n\tconst closeMic = () => {\n\t\tsetRunning(false);\n\t\tif (analyser) {\n\t\t\tanalyser.disconnect(0);\n\t\t\tsetAnalyser(null);\n\t\t}\n\t\tif (audioInput) {\n\t\t\taudioInput.disconnect(0);\n\t\t\tsetAudioInput(null);\n\t\t}\n\t\tif (stream) {\n\t\t\tstream.getAudioTracks().forEach((track: any) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tsetStream(null);\n\t\t}\n\t};\n\n\tconst stop = () => {\n\t\tcloseMic();\n\t};\n\n\treturn (\n\t\t<Box\n\t\t\tjustify=\"center\"\n\t\t\talignSelf=\"center\"\n\t\t\tmargin=\"small\"\n\t\t\tborder={{ color: 'brand', size: 'small' }}\n\t\t\tround=\"large\"\n\t\t\tbackground=\"light-1\"\n\t\t>\n\t\t\t<Header justify=\"center\" height=\"xxsmall\" background=\"light-6\" round={{ corner: 'top', size: 'large' }}>\n\t\t\t\t<Heading level=\"2\" margin=\"none\">\n\t\t\t\t\tLightshow with Shellys\n\t\t\t\t</Heading>\n\t\t\t</Header>\n\t\t\t<Box border={[{ color: 'brand', size: 'small', side: 'bottom' }]} />\n\t\t\t<Main alignSelf=\"center\" pad=\"small\" justify=\"center\">\n\t\t\t\t<Box direction=\"row\" justify=\"center\" gap=\"medium\" margin=\"small\">\n\t\t\t\t\t{!running ? <Button onClick={start} label=\"Start\" /> : <Button onClick={stop} label=\"Stop\" />}\n\t\t\t\t</Box>\n\n\t\t\t\t<VisualController running={running} analyser={analyser} />\n\t\t\t\t<ShellyController running={running} analyser={analyser} />\n\t\t\t</Main>\n\t\t</Box>\n\t);\n};\n\nexport default Controller;\n","import { grommet, Grommet } from 'grommet';\nimport React from 'react';\nimport './App.css';\nimport Controller from './controllers/controller';\n\nconst App = (): JSX.Element => {\n\treturn (\n\t\t<>\n\t\t\t<Grommet theme={grommet}>\n\t\t\t\t<Controller />\n\t\t\t</Grommet>\n\t\t</>\n\t);\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost' ||\n\t\t// [::1] is the IPv6 localhost address.\n\t\twindow.location.hostname === '[::1]' ||\n\t\t// 127.0.0.0/8 are considered localhost for IPv4.\n\t\twindow.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\ntype Config = {\n\tonSuccess?: (registration: ServiceWorkerRegistration) => void;\n\tonUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebook/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Let's check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl, config);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then(() => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'This web app is being served cache-first by a service ' +\n\t\t\t\t\t\t\t'worker. To learn more, visit https://cra.link/PWA',\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not localhost. Just register service worker\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then((registration) => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tif (installingWorker == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the updated precached content has been fetched,\n\t\t\t\t\t\t\t// but the previous service worker will still serve the older\n\t\t\t\t\t\t\t// content until all client tabs are closed.\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t'New content is available and will be used when all ' +\n\t\t\t\t\t\t\t\t\t'tabs for this page are closed. See https://cra.link/PWA.',\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onUpdate) {\n\t\t\t\t\t\t\t\tconfig.onUpdate(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onSuccess) {\n\t\t\t\t\t\t\t\tconfig.onSuccess(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch((error) => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl, {\n\t\theaders: { 'Service-Worker': 'script' },\n\t})\n\t\t.then((response) => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tconst contentType = response.headers.get('content-type');\n\t\t\tif (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then((registration) => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log('No internet connection found. App is running in offline mode.');\n\t\t});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready\n\t\t\t.then((registration) => {\n\t\t\t\tregistration.unregister();\n\t\t\t})\n\t\t\t.catch((error) => {\n\t\t\t\tconsole.error(error.message);\n\t\t\t});\n\t}\n}\n","/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n\tif (onPerfEntry && onPerfEntry instanceof Function) {\n\t\timport('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n\t\t\tgetCLS(onPerfEntry);\n\t\t\tgetFID(onPerfEntry);\n\t\t\tgetFCP(onPerfEntry);\n\t\t\tgetLCP(onPerfEntry);\n\t\t\tgetTTFB(onPerfEntry);\n\t\t});\n\t}\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}